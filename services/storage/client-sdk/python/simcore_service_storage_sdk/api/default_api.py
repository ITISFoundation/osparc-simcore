# coding: utf-8

"""
    simcore-service-storage API

    API definition for simcore-service-storage service  # noqa: E501

    OpenAPI spec version: 0.2.1
    Contact: support@simcore.io
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six
from simcore_service_storage_sdk.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def check_action_post(self, action, **kwargs):  # noqa: E501
        """Test checkpoint to ask server to fail or echo back the transmitted data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_action_post(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: (required)
        :param str data:
        :param Fake fake:
        :return: FakeEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.check_action_post_with_http_info(action, **kwargs)  # noqa: E501
        else:
            (data) = self.check_action_post_with_http_info(
                action, **kwargs
            )  # noqa: E501
            return data

    def check_action_post_with_http_info(self, action, **kwargs):  # noqa: E501
        """Test checkpoint to ask server to fail or echo back the transmitted data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_action_post_with_http_info(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: (required)
        :param str data:
        :param Fake fake:
        :return: FakeEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["action", "data", "fake"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_action_post" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'action' is set
        if "action" not in local_var_params or local_var_params["action"] is None:
            raise ValueError(
                "Missing the required parameter `action` when calling `check_action_post`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "action" in local_var_params:
            path_params["action"] = local_var_params["action"]  # noqa: E501

        query_params = []
        if "data" in local_var_params:
            query_params.append(("data", local_var_params["data"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "fake" in local_var_params:
            body_params = local_var_params["fake"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/check/{action}",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FakeEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def copy_as_soft_link(self, file_id, user_id, **kwargs):  # noqa: E501
        """Copy as soft link  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_as_soft_link(file_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param int user_id: (required)
        :param InlineObject1 inline_object1:
        :return: FileMetaDataEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.copy_as_soft_link_with_http_info(
                file_id, user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.copy_as_soft_link_with_http_info(
                file_id, user_id, **kwargs
            )  # noqa: E501
            return data

    def copy_as_soft_link_with_http_info(
        self, file_id, user_id, **kwargs
    ):  # noqa: E501
        """Copy as soft link  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_as_soft_link_with_http_info(file_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param int user_id: (required)
        :param InlineObject1 inline_object1:
        :return: FileMetaDataEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["file_id", "user_id", "inline_object1"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_as_soft_link" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'file_id' is set
        if "file_id" not in local_var_params or local_var_params["file_id"] is None:
            raise ValueError(
                "Missing the required parameter `file_id` when calling `copy_as_soft_link`"
            )  # noqa: E501
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `copy_as_soft_link`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "file_id" in local_var_params:
            path_params["file_id"] = local_var_params["file_id"]  # noqa: E501

        query_params = []
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "inline_object1" in local_var_params:
            body_params = local_var_params["inline_object1"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/files/{file_id}:soft-copy",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FileMetaDataEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def copy_folders_from_project(self, user_id, **kwargs):  # noqa: E501
        """Deep copies of all data from source to destination project in s3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_folders_from_project(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: (required)
        :param InlineObject inline_object:
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.copy_folders_from_project_with_http_info(
                user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.copy_folders_from_project_with_http_info(
                user_id, **kwargs
            )  # noqa: E501
            return data

    def copy_folders_from_project_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Deep copies of all data from source to destination project in s3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_folders_from_project_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: (required)
        :param InlineObject inline_object:
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["user_id", "inline_object"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_folders_from_project" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `copy_folders_from_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "inline_object" in local_var_params:
            body_params = local_var_params["inline_object"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/simcore-s3/folders",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Project",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def delete_file(self, file_id, location_id, user_id, **kwargs):  # noqa: E501
        """Deletes file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file(file_id, location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param str location_id: (required)
        :param str user_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_file_with_http_info(
                file_id, location_id, user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.delete_file_with_http_info(
                file_id, location_id, user_id, **kwargs
            )  # noqa: E501
            return data

    def delete_file_with_http_info(
        self, file_id, location_id, user_id, **kwargs
    ):  # noqa: E501
        """Deletes file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file_with_http_info(file_id, location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param str location_id: (required)
        :param str user_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["file_id", "location_id", "user_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'file_id' is set
        if "file_id" not in local_var_params or local_var_params["file_id"] is None:
            raise ValueError(
                "Missing the required parameter `file_id` when calling `delete_file`"
            )  # noqa: E501
        # verify the required parameter 'location_id' is set
        if (
            "location_id" not in local_var_params
            or local_var_params["location_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `location_id` when calling `delete_file`"
            )  # noqa: E501
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `delete_file`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "file_id" in local_var_params:
            path_params["fileId"] = local_var_params["file_id"]  # noqa: E501
        if "location_id" in local_var_params:
            path_params["location_id"] = local_var_params["location_id"]  # noqa: E501

        query_params = []
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/locations/{location_id}/files/{fileId}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def delete_folders_of_project(self, folder_id, user_id, **kwargs):  # noqa: E501
        """Deletes all objects within a node_id or within a project_id if node_id is omitted  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folders_of_project(folder_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: (required)
        :param str user_id: (required)
        :param str node_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_folders_of_project_with_http_info(
                folder_id, user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.delete_folders_of_project_with_http_info(
                folder_id, user_id, **kwargs
            )  # noqa: E501
            return data

    def delete_folders_of_project_with_http_info(
        self, folder_id, user_id, **kwargs
    ):  # noqa: E501
        """Deletes all objects within a node_id or within a project_id if node_id is omitted  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folders_of_project_with_http_info(folder_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: (required)
        :param str user_id: (required)
        :param str node_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["folder_id", "user_id", "node_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_folders_of_project" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'folder_id' is set
        if "folder_id" not in local_var_params or local_var_params["folder_id"] is None:
            raise ValueError(
                "Missing the required parameter `folder_id` when calling `delete_folders_of_project`"
            )  # noqa: E501
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `delete_folders_of_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "folder_id" in local_var_params:
            path_params["folder_id"] = local_var_params["folder_id"]  # noqa: E501

        query_params = []
        if "node_id" in local_var_params:
            query_params.append(("node_id", local_var_params["node_id"]))  # noqa: E501
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/simcore-s3/folders/{folder_id}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def download_file(self, file_id, location_id, user_id, **kwargs):  # noqa: E501
        """Gets download link for file at location  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_file(file_id, location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param str location_id: (required)
        :param str user_id: (required)
        :return: PresignedLinkEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.download_file_with_http_info(
                file_id, location_id, user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.download_file_with_http_info(
                file_id, location_id, user_id, **kwargs
            )  # noqa: E501
            return data

    def download_file_with_http_info(
        self, file_id, location_id, user_id, **kwargs
    ):  # noqa: E501
        """Gets download link for file at location  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_file_with_http_info(file_id, location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param str location_id: (required)
        :param str user_id: (required)
        :return: PresignedLinkEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["file_id", "location_id", "user_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_file" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'file_id' is set
        if "file_id" not in local_var_params or local_var_params["file_id"] is None:
            raise ValueError(
                "Missing the required parameter `file_id` when calling `download_file`"
            )  # noqa: E501
        # verify the required parameter 'location_id' is set
        if (
            "location_id" not in local_var_params
            or local_var_params["location_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `location_id` when calling `download_file`"
            )  # noqa: E501
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `download_file`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "file_id" in local_var_params:
            path_params["fileId"] = local_var_params["file_id"]  # noqa: E501
        if "location_id" in local_var_params:
            path_params["location_id"] = local_var_params["location_id"]  # noqa: E501

        query_params = []
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/locations/{location_id}/files/{fileId}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PresignedLinkEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_datasets_metadata(self, location_id, user_id, **kwargs):  # noqa: E501
        """Lists all dataset's metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasets_metadata(location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: (required)
        :param str user_id: (required)
        :return: DatasetMetaDataArrayEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_datasets_metadata_with_http_info(
                location_id, user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_datasets_metadata_with_http_info(
                location_id, user_id, **kwargs
            )  # noqa: E501
            return data

    def get_datasets_metadata_with_http_info(
        self, location_id, user_id, **kwargs
    ):  # noqa: E501
        """Lists all dataset's metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasets_metadata_with_http_info(location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: (required)
        :param str user_id: (required)
        :return: DatasetMetaDataArrayEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["location_id", "user_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datasets_metadata" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'location_id' is set
        if (
            "location_id" not in local_var_params
            or local_var_params["location_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `location_id` when calling `get_datasets_metadata`"
            )  # noqa: E501
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `get_datasets_metadata`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "location_id" in local_var_params:
            path_params["location_id"] = local_var_params["location_id"]  # noqa: E501

        query_params = []
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/locations/{location_id}/datasets",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="DatasetMetaDataArrayEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_file_metadata(self, file_id, location_id, user_id, **kwargs):  # noqa: E501
        """Get file metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_metadata(file_id, location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param str location_id: (required)
        :param str user_id: (required)
        :return: FileMetaDataEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_file_metadata_with_http_info(
                file_id, location_id, user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_file_metadata_with_http_info(
                file_id, location_id, user_id, **kwargs
            )  # noqa: E501
            return data

    def get_file_metadata_with_http_info(
        self, file_id, location_id, user_id, **kwargs
    ):  # noqa: E501
        """Get file metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_metadata_with_http_info(file_id, location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param str location_id: (required)
        :param str user_id: (required)
        :return: FileMetaDataEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["file_id", "location_id", "user_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_metadata" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'file_id' is set
        if "file_id" not in local_var_params or local_var_params["file_id"] is None:
            raise ValueError(
                "Missing the required parameter `file_id` when calling `get_file_metadata`"
            )  # noqa: E501
        # verify the required parameter 'location_id' is set
        if (
            "location_id" not in local_var_params
            or local_var_params["location_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `location_id` when calling `get_file_metadata`"
            )  # noqa: E501
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `get_file_metadata`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "file_id" in local_var_params:
            path_params["fileId"] = local_var_params["file_id"]  # noqa: E501
        if "location_id" in local_var_params:
            path_params["location_id"] = local_var_params["location_id"]  # noqa: E501

        query_params = []
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/locations/{location_id}/files/{fileId}/metadata",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FileMetaDataEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_files_metadata(self, location_id, user_id, **kwargs):  # noqa: E501
        """Lists all file's metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_files_metadata(location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: (required)
        :param str user_id: (required)
        :param str uuid_filter:
        :return: FileMetaDataArrayEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_files_metadata_with_http_info(
                location_id, user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_files_metadata_with_http_info(
                location_id, user_id, **kwargs
            )  # noqa: E501
            return data

    def get_files_metadata_with_http_info(
        self, location_id, user_id, **kwargs
    ):  # noqa: E501
        """Lists all file's metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_files_metadata_with_http_info(location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: (required)
        :param str user_id: (required)
        :param str uuid_filter:
        :return: FileMetaDataArrayEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["location_id", "user_id", "uuid_filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_files_metadata" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'location_id' is set
        if (
            "location_id" not in local_var_params
            or local_var_params["location_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `location_id` when calling `get_files_metadata`"
            )  # noqa: E501
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `get_files_metadata`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "location_id" in local_var_params:
            path_params["location_id"] = local_var_params["location_id"]  # noqa: E501

        query_params = []
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501
        if "uuid_filter" in local_var_params:
            query_params.append(
                ("uuid_filter", local_var_params["uuid_filter"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/locations/{location_id}/files/metadata",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FileMetaDataArrayEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_files_metadata_dataset(
        self, location_id, dataset_id, user_id, **kwargs
    ):  # noqa: E501
        """Get dataset metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_files_metadata_dataset(location_id, dataset_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: (required)
        :param str dataset_id: (required)
        :param str user_id: (required)
        :return: FileMetaDataArrayEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_files_metadata_dataset_with_http_info(
                location_id, dataset_id, user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_files_metadata_dataset_with_http_info(
                location_id, dataset_id, user_id, **kwargs
            )  # noqa: E501
            return data

    def get_files_metadata_dataset_with_http_info(
        self, location_id, dataset_id, user_id, **kwargs
    ):  # noqa: E501
        """Get dataset metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_files_metadata_dataset_with_http_info(location_id, dataset_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: (required)
        :param str dataset_id: (required)
        :param str user_id: (required)
        :return: FileMetaDataArrayEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["location_id", "dataset_id", "user_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_files_metadata_dataset" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'location_id' is set
        if (
            "location_id" not in local_var_params
            or local_var_params["location_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `location_id` when calling `get_files_metadata_dataset`"
            )  # noqa: E501
        # verify the required parameter 'dataset_id' is set
        if (
            "dataset_id" not in local_var_params
            or local_var_params["dataset_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `dataset_id` when calling `get_files_metadata_dataset`"
            )  # noqa: E501
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `get_files_metadata_dataset`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "location_id" in local_var_params:
            path_params["location_id"] = local_var_params["location_id"]  # noqa: E501
        if "dataset_id" in local_var_params:
            path_params["dataset_id"] = local_var_params["dataset_id"]  # noqa: E501

        query_params = []
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/locations/{location_id}/datasets/{dataset_id}/metadata",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FileMetaDataArrayEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_status(self, **kwargs):  # noqa: E501
        """checks status of self and connected services  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_status_with_http_info(self, **kwargs):  # noqa: E501
        """checks status of self and connected services  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_status" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/status",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_storage_locations(self, user_id, **kwargs):  # noqa: E501
        """Lists available storage locations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_storage_locations(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: (required)
        :return: FileLocationArrayEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_storage_locations_with_http_info(
                user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_storage_locations_with_http_info(
                user_id, **kwargs
            )  # noqa: E501
            return data

    def get_storage_locations_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Lists available storage locations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_storage_locations_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: (required)
        :return: FileLocationArrayEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["user_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_storage_locations" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `get_storage_locations`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/locations",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FileLocationArrayEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def health_check(self, **kwargs):  # noqa: E501
        """Service health-check endpoint  # noqa: E501

        Some general information on the API and state of the service behind  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_check(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HealthCheckEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.health_check_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.health_check_with_http_info(**kwargs)  # noqa: E501
            return data

    def health_check_with_http_info(self, **kwargs):  # noqa: E501
        """Service health-check endpoint  # noqa: E501

        Some general information on the API and state of the service behind  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_check_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HealthCheckEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method health_check" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="HealthCheckEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def search_files_starting_with(self, user_id, **kwargs):  # noqa: E501
        """Returns metadata for all files matching a pattern  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_files_starting_with(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: (required)
        :param str startswith: matches starting string of the file_uuid
        :return: FileMetaDataArrayEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.search_files_starting_with_with_http_info(
                user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.search_files_starting_with_with_http_info(
                user_id, **kwargs
            )  # noqa: E501
            return data

    def search_files_starting_with_with_http_info(
        self, user_id, **kwargs
    ):  # noqa: E501
        """Returns metadata for all files matching a pattern  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_files_starting_with_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: (required)
        :param str startswith: matches starting string of the file_uuid
        :return: FileMetaDataArrayEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["user_id", "startswith"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_files_starting_with" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `search_files_starting_with`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501
        if "startswith" in local_var_params:
            query_params.append(
                ("startswith", local_var_params["startswith"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/simcore-s3/files/metadata:search",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FileMetaDataArrayEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def synchronise_meta_data_table(self, location_id, **kwargs):  # noqa: E501
        """Manually triggers the synchronisation of the file meta data table in the database  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronise_meta_data_table(location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: (required)
        :param bool dry_run:
        :param bool fire_and_forget:
        :return: TableSynchronisationEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.synchronise_meta_data_table_with_http_info(
                location_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.synchronise_meta_data_table_with_http_info(
                location_id, **kwargs
            )  # noqa: E501
            return data

    def synchronise_meta_data_table_with_http_info(
        self, location_id, **kwargs
    ):  # noqa: E501
        """Manually triggers the synchronisation of the file meta data table in the database  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronise_meta_data_table_with_http_info(location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: (required)
        :param bool dry_run:
        :param bool fire_and_forget:
        :return: TableSynchronisationEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["location_id", "dry_run", "fire_and_forget"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method synchronise_meta_data_table" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'location_id' is set
        if (
            "location_id" not in local_var_params
            or local_var_params["location_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `location_id` when calling `synchronise_meta_data_table`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "location_id" in local_var_params:
            path_params["location_id"] = local_var_params["location_id"]  # noqa: E501

        query_params = []
        if "dry_run" in local_var_params:
            query_params.append(("dry_run", local_var_params["dry_run"]))  # noqa: E501
        if "fire_and_forget" in local_var_params:
            query_params.append(
                ("fire_and_forget", local_var_params["fire_and_forget"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/locations/{location_id}:sync",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="TableSynchronisationEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def update_file_meta_data(self, file_id, location_id, **kwargs):  # noqa: E501
        """Update file metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_file_meta_data(file_id, location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param str location_id: (required)
        :param FileMetaData file_meta_data:
        :return: FileMetaDataEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.update_file_meta_data_with_http_info(
                file_id, location_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.update_file_meta_data_with_http_info(
                file_id, location_id, **kwargs
            )  # noqa: E501
            return data

    def update_file_meta_data_with_http_info(
        self, file_id, location_id, **kwargs
    ):  # noqa: E501
        """Update file metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_file_meta_data_with_http_info(file_id, location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param str location_id: (required)
        :param FileMetaData file_meta_data:
        :return: FileMetaDataEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ["file_id", "location_id", "file_meta_data"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_file_meta_data" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'file_id' is set
        if "file_id" not in local_var_params or local_var_params["file_id"] is None:
            raise ValueError(
                "Missing the required parameter `file_id` when calling `update_file_meta_data`"
            )  # noqa: E501
        # verify the required parameter 'location_id' is set
        if (
            "location_id" not in local_var_params
            or local_var_params["location_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `location_id` when calling `update_file_meta_data`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "file_id" in local_var_params:
            path_params["fileId"] = local_var_params["file_id"]  # noqa: E501
        if "location_id" in local_var_params:
            path_params["location_id"] = local_var_params["location_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "file_meta_data" in local_var_params:
            body_params = local_var_params["file_meta_data"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/locations/{location_id}/files/{fileId}/metadata",
            "PATCH",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FileMetaDataEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def upload_file(self, file_id, location_id, user_id, **kwargs):  # noqa: E501
        """Returns upload link or performs copy operation to datcore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file(file_id, location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param str location_id: (required)
        :param str user_id: (required)
        :param str extra_location:
        :param str extra_source:
        :return: PresignedLinkEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.upload_file_with_http_info(
                file_id, location_id, user_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.upload_file_with_http_info(
                file_id, location_id, user_id, **kwargs
            )  # noqa: E501
            return data

    def upload_file_with_http_info(
        self, file_id, location_id, user_id, **kwargs
    ):  # noqa: E501
        """Returns upload link or performs copy operation to datcore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_with_http_info(file_id, location_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: (required)
        :param str location_id: (required)
        :param str user_id: (required)
        :param str extra_location:
        :param str extra_source:
        :return: PresignedLinkEnveloped
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            "file_id",
            "location_id",
            "user_id",
            "extra_location",
            "extra_source",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'file_id' is set
        if "file_id" not in local_var_params or local_var_params["file_id"] is None:
            raise ValueError(
                "Missing the required parameter `file_id` when calling `upload_file`"
            )  # noqa: E501
        # verify the required parameter 'location_id' is set
        if (
            "location_id" not in local_var_params
            or local_var_params["location_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `location_id` when calling `upload_file`"
            )  # noqa: E501
        # verify the required parameter 'user_id' is set
        if "user_id" not in local_var_params or local_var_params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `upload_file`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "file_id" in local_var_params:
            path_params["fileId"] = local_var_params["file_id"]  # noqa: E501
        if "location_id" in local_var_params:
            path_params["location_id"] = local_var_params["location_id"]  # noqa: E501

        query_params = []
        if "user_id" in local_var_params:
            query_params.append(("user_id", local_var_params["user_id"]))  # noqa: E501
        if "extra_location" in local_var_params:
            query_params.append(
                ("extra_location", local_var_params["extra_location"])
            )  # noqa: E501
        if "extra_source" in local_var_params:
            query_params.append(
                ("extra_source", local_var_params["extra_source"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/locations/{location_id}/files/{fileId}",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PresignedLinkEnveloped",  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
