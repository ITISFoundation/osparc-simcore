/* ************************************************************************

   osparc - the simcore frontend

   https://osparc.io

   Copyright:
     2018 IT'IS Foundation, https://itis.swiss

   License:
     MIT: https://opensource.org/licenses/MIT

   Authors:
     * Odei Maiz (odeimaiz)

************************************************************************ */

/**
 * Widget that contains FilesTree showing:
 * - data generated by the node
 * and a FileLabelWithActions for letting the user download and/or remove files.
 *
 * *Example*
 *
 * Here is a little example of how to use the widget.
 *
 * <pre class='javascript'>
 *   let dataManager = new osparc.widget.NodeDataManager(null, nodeId);
 *   this.getRoot().add(dataManager);
 * </pre>
 */

qx.Class.define("osparc.widget.NodeDataManager", {
  extend: qx.ui.core.Widget,

  /**
    * @param studyId {String} StudyId
    * @param nodeId {String} NodeId
    */
  construct: function(studyId, nodeId) {
    this.base(arguments);

    this._setLayout(new qx.ui.layout.VBox(10));

    if (studyId) {
      this.set({
        studyId
      });
    }

    if (nodeId) {
      this.set({
        nodeId
      });
    }

    this.__buildLayout();
    this.__reloadTree();
  },

  properties: {
    studyId: {
      check: "String",
      init: null,
      nullable: false
    },

    nodeId: {
      check: "String",
      init: null,
      nullable: false
    }
  },

  members: {
    _createChildControlImpl: function(id) {
      let control;
      switch (id) {
        case "tree-folder-view":
          control = new osparc.file.TreeFolderView();
          this._add(control, {
            flex: 1
          });
          break;
      }

      return control || this.base(arguments, id);
    },

    __buildLayout: function() {
      const treeFolderView = this.getChildControl("tree-folder-view");
      treeFolderView.getChildControl("folder-tree").setBackgroundColor("window-popup-background");

      const reloadButton = treeFolderView.getChildControl("reload-button");
      reloadButton.addListener("execute", () => this.__reloadTree(), this);

      const selectedFileLayout = treeFolderView.getChildControl("folder-viewer").getChildControl("selected-file-layout");
      selectedFileLayout.addListener("fileDeleted", e => this.__fileDeleted(e.getData()), this);
    },

    __reloadTree: function() {
      const treeFolderView = this.getChildControl("tree-folder-view");

      const foldersTree = treeFolderView.getChildControl("folder-tree");
      foldersTree.resetCache();
      if (this.getStudyId()) {
        foldersTree.populateStudyTree(this.getStudyId());
      }
      if (this.getNodeId()) {
        foldersTree.populateNodeTree(this.getNodeId());
      }

      const folderViewer = treeFolderView.getChildControl("folder-viewer");
      folderViewer.resetFolder();
    },

    __fileDeleted: function(fileMetadata) {
      // After deleting a file, try to keep the user in the same folder.
      // If the folder doesn't longer exist, open the closest available parent

      const path = fileMetadata["fileUuid"].split("/");

      const treeFolderView = this.getChildControl("tree-folder-view");
      const foldersTree = treeFolderView.getChildControl("folder-tree");
      foldersTree.resetCache();

      const openSameFolder = () => {
        // drop last, which is the file
        path.pop();
        treeFolderView.openPath(path);
      };

      if (this.getStudyId()) {
        foldersTree.populateStudyTree(this.getStudyId())
          .then(() => openSameFolder())
          .catch(err => console.error(err));
      }
      if (this.getNodeId()) {
        foldersTree.populateNodeTree(this.getNodeId())
          .then(() => openSameFolder())
          .catch(err => console.error(err));
      }
    }
  }
});
