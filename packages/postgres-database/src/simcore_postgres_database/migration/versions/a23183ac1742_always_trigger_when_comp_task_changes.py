"""always trigger when comp_task changes

Revision ID: a23183ac1742
Revises: cfd1c43b5d33
Create Date: 2020-11-27 12:30:13.836161+00:00

"""

import sqlalchemy as sa
from alembic import op

# revision identifiers, used by Alembic.
revision = "a23183ac1742"
down_revision = "cfd1c43b5d33"
branch_labels = None
depends_on = None

DB_PROCEDURE_NAME: str = "notify_comp_tasks_changed"
DB_TRIGGER_NAME: str = f"{DB_PROCEDURE_NAME}_event"
DB_CHANNEL_NAME: str = "comp_tasks_output_events"


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    drop_trigger = sa.DDL(
        f"""
DROP TRIGGER IF EXISTS {DB_TRIGGER_NAME} on comp_tasks;
"""
    )

    task_output_changed_procedure = sa.DDL(
        f"""
    CREATE OR REPLACE FUNCTION {DB_PROCEDURE_NAME}() RETURNS TRIGGER AS $$
        DECLARE
            record RECORD;
            payload JSON;
            changes JSONB;
        BEGIN
            IF (TG_OP = 'DELETE') THEN
                record = OLD;
            ELSE
                record = NEW;
            END IF;

            SELECT jsonb_agg(pre.key ORDER BY pre.key) INTO changes
            FROM jsonb_each(to_jsonb(OLD)) AS pre, jsonb_each(to_jsonb(NEW)) AS post
            WHERE pre.key = post.key AND pre.value IS DISTINCT FROM post.value;

            payload = json_build_object('table', TG_TABLE_NAME,
                                        'changes', changes,
                                        'action', TG_OP,
                                        'data', row_to_json(record));

            PERFORM pg_notify('{DB_CHANNEL_NAME}', payload::text);

            RETURN NULL;
        END;
    $$ LANGUAGE plpgsql;
    """
    )

    task_output_changed_trigger = sa.DDL(
        f"""
DROP TRIGGER IF EXISTS {DB_TRIGGER_NAME} on comp_tasks;
CREATE TRIGGER {DB_TRIGGER_NAME}
AFTER UPDATE OF outputs,state ON comp_tasks
    FOR EACH ROW
    WHEN ((OLD.outputs::jsonb IS DISTINCT FROM NEW.outputs::jsonb OR OLD.state IS DISTINCT FROM NEW.state))
    EXECUTE PROCEDURE {DB_PROCEDURE_NAME}();
"""
    )

    op.execute(drop_trigger)
    op.execute(task_output_changed_procedure)
    op.execute(task_output_changed_trigger)
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    drop_trigger = sa.DDL(
        f"""
DROP TRIGGER IF EXISTS {DB_TRIGGER_NAME} on comp_tasks;
"""
    )

    task_output_changed_procedure = sa.DDL(
        f"""
    CREATE OR REPLACE FUNCTION {DB_PROCEDURE_NAME}() RETURNS TRIGGER AS $$
        DECLARE
            record RECORD;
            payload JSON;
        BEGIN
            IF (TG_OP = 'DELETE') THEN
                record = OLD;
            ELSE
                record = NEW;
            END IF;

            payload = json_build_object('table', TG_TABLE_NAME,
                                        'action', TG_OP,
                                        'data', row_to_json(record));

            PERFORM pg_notify('{DB_CHANNEL_NAME}', payload::text);

            RETURN NULL;
        END;
    $$ LANGUAGE plpgsql;
    """
    )

    task_output_changed_trigger = sa.DDL(
        f"""
DROP TRIGGER IF EXISTS {DB_TRIGGER_NAME} on comp_tasks;
CREATE TRIGGER {DB_TRIGGER_NAME}
AFTER UPDATE OF outputs,state ON comp_tasks
    FOR EACH ROW
    WHEN ((OLD.outputs::jsonb IS DISTINCT FROM NEW.outputs::jsonb OR OLD.state IS DISTINCT FROM NEW.state)
    AND NEW.node_class <> 'FRONTEND')
    EXECUTE PROCEDURE {DB_PROCEDURE_NAME}();
"""
    )

    op.execute(drop_trigger)
    op.execute(task_output_changed_procedure)
    op.execute(task_output_changed_trigger)
    # ### end Alembic commands ###
