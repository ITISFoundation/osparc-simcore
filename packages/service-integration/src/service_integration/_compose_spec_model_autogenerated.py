# generated by datamodel-codegen:
#   filename:  compose-spec.json
#   timestamp: 2025-11-13T10:55:14+00:00

from __future__ import annotations

from typing import Annotated, Any, Literal

from pydantic import BaseModel, ConfigDict, Field, RootModel


class CpuCount(RootModel[int]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[int, Field(description="Number of usable CPUs.", ge=0)]


class CpuPercent(RootModel[int]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        int, Field(description="Percentage of CPU resources to use.", ge=0, le=100)
    ]


class CredentialSpec(BaseModel):
    """
    Configure the credential spec for managed service account.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    config: Annotated[
        str | None, Field(description="The name of the credential spec Config to use.")
    ] = None
    file: Annotated[
        str | None, Field(description="Path to a credential spec file.")
    ] = None
    registry: Annotated[
        str | None,
        Field(description="Path to a credential spec in the Windows registry."),
    ] = None


class DependsOn(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    restart: Annotated[
        bool | str | None,
        Field(
            description="Whether to restart dependent services when this service is restarted."
        ),
    ] = None
    required: Annotated[
        bool | None,
        Field(
            description="Whether the dependency is required for the dependent service to start."
        ),
    ] = True
    condition: Annotated[
        Literal["service_started", "service_healthy", "service_completed_successfully"],
        Field(
            description="Condition to wait for. 'service_started' waits until the service has started, 'service_healthy' waits until the service is healthy (as defined by its healthcheck), 'service_completed_successfully' waits until the service has completed successfully."
        ),
    ]


class Devices(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    source: Annotated[str, Field(description="Path on the host to the device.")]
    target: Annotated[
        str | None,
        Field(description="Path in the container where the device will be mapped."),
    ] = None
    permissions: Annotated[
        str | None, Field(description="Cgroup permissions for the device (rwm).")
    ] = None


class Extends(BaseModel):
    """
    Extend another service, in the current file or another file.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    service: Annotated[str, Field(description="The name of the service to extend.")]
    file: Annotated[
        str | None,
        Field(description="The file path where the service to extend is defined."),
    ] = None


class Provider(BaseModel):
    """
    Specify a service which will not be manage by Compose directly, and delegate its management to an external provider.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    type: Annotated[
        str,
        Field(
            description="External component used by Compose to manage setup and teardown lifecycle of the service."
        ),
    ]
    options: Annotated[
        dict[str, str | float | bool | list[str | float | bool]] | None,
        Field(description="Provider-specific options."),
    ] = None


class Logging(BaseModel):
    """
    Logging configuration for the service.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    driver: Annotated[
        str | None,
        Field(
            description="Logging driver to use, such as 'json-file', 'syslog', 'journald', etc."
        ),
    ] = None
    options: Annotated[
        dict[str, str | float | None] | None,
        Field(description="Options for the logging driver."),
    ] = None


class Models(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    endpoint_var: Annotated[
        str | None, Field(description="Environment variable set to AI model endpoint.")
    ] = None
    model_var: Annotated[
        str | None, Field(description="Environment variable set to AI model name.")
    ] = None


class OomScoreAdj(RootModel[int]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        int,
        Field(
            description="Tune host's OOM preferences for the container (accepts -1000 to 1000).",
            ge=-1000,
            le=1000,
        ),
    ]


class Ports(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: Annotated[
        str | None, Field(description="A human-readable name for this port mapping.")
    ] = None
    mode: Annotated[
        str | None,
        Field(
            description="The port binding mode, either 'host' for publishing a host port or 'ingress' for load balancing."
        ),
    ] = None
    host_ip: Annotated[str | None, Field(description="The host IP to bind to.")] = None
    target: Annotated[
        int | str | None, Field(description="The port inside the container.")
    ] = None
    published: Annotated[
        str | int | None, Field(description="The publicly exposed port.")
    ] = None
    protocol: Annotated[
        str | None, Field(description="The port protocol (tcp or udp).")
    ] = None
    app_protocol: Annotated[
        str | None,
        Field(
            description="Application protocol to use with the port (e.g., http, https, mysql)."
        ),
    ] = None


class Bind(BaseModel):
    """
    Configuration specific to bind mounts.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    propagation: Annotated[
        str | None,
        Field(
            description="The propagation mode for the bind mount: 'shared', 'slave', 'private', 'rshared', 'rslave', or 'rprivate'."
        ),
    ] = None
    create_host_path: Annotated[
        bool | str | None,
        Field(description="Create the host path if it doesn't exist."),
    ] = None
    recursive: Annotated[
        Literal["enabled", "disabled", "writable", "readonly"] | None,
        Field(description="Recursively mount the source directory."),
    ] = None
    selinux: Annotated[
        Literal["z", "Z"] | None,
        Field(
            description="SELinux relabeling options: 'z' for shared content, 'Z' for private unshared content."
        ),
    ] = None


class Size(RootModel[int]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[int, Field(description="Size of the tmpfs mount in bytes.", ge=0)]


class Tmpfs(BaseModel):
    """
    Configuration specific to tmpfs mounts.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    size: Annotated[
        Size | str | None, Field(description="Size of the tmpfs mount in bytes.")
    ] = None
    mode: Annotated[
        float | str | None, Field(description="File mode of the tmpfs in octal.")
    ] = None


class Image(BaseModel):
    """
    Configuration specific to image mounts.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    subpath: Annotated[
        str | None,
        Field(description="Path within the image to mount instead of the image root."),
    ] = None


class Healthcheck(BaseModel):
    """
    Configuration options to determine whether the container is healthy.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    disable: Annotated[
        bool | str | None,
        Field(
            description="Disable any container-specified healthcheck. Set to true to disable."
        ),
    ] = None
    interval: Annotated[
        str | None,
        Field(
            description="Time between running the check (e.g., '1s', '1m30s'). Default: 30s."
        ),
    ] = None
    retries: Annotated[
        float | str | None,
        Field(
            description="Number of consecutive failures needed to consider the container as unhealthy. Default: 3."
        ),
    ] = None
    test: Annotated[
        str | list[str] | None,
        Field(
            description="The test to perform to check container health. Can be a string or a list. The first item is either NONE, CMD, or CMD-SHELL. If it's CMD, the rest of the command is exec'd. If it's CMD-SHELL, the rest is run in the shell."
        ),
    ] = None
    timeout: Annotated[
        str | None,
        Field(
            description="Maximum time to allow one check to run (e.g., '1s', '1m30s'). Default: 30s."
        ),
    ] = None
    start_period: Annotated[
        str | None,
        Field(
            description="Start period for the container to initialize before starting health-retries countdown (e.g., '1s', '1m30s'). Default: 0s."
        ),
    ] = None
    start_interval: Annotated[
        str | None,
        Field(
            description="Time between running the check during the start period (e.g., '1s', '1m30s'). Default: interval value."
        ),
    ] = None


class RollbackConfig(BaseModel):
    """
    Configuration for rolling back a service update.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    parallelism: Annotated[
        int | str | None,
        Field(
            description="The number of containers to rollback at a time. If set to 0, all containers rollback simultaneously."
        ),
    ] = None
    delay: Annotated[
        str | None,
        Field(
            description="The time to wait between each container group's rollback (e.g., '1s', '1m30s')."
        ),
    ] = None
    failure_action: Annotated[
        str | None,
        Field(description="Action to take if a rollback fails: 'continue', 'pause'."),
    ] = None
    monitor: Annotated[
        str | None,
        Field(
            description="Duration to monitor each task for failures after it is created (e.g., '1s', '1m30s')."
        ),
    ] = None
    max_failure_ratio: Annotated[
        float | str | None,
        Field(description="Failure rate to tolerate during a rollback."),
    ] = None
    order: Annotated[
        Literal["start-first", "stop-first"] | None,
        Field(
            description="Order of operations during rollbacks: 'stop-first' (default) or 'start-first'."
        ),
    ] = None


class UpdateConfig(BaseModel):
    """
    Configuration for updating a service.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    parallelism: Annotated[
        int | str | None,
        Field(description="The number of containers to update at a time."),
    ] = None
    delay: Annotated[
        str | None,
        Field(
            description="The time to wait between updating a group of containers (e.g., '1s', '1m30s')."
        ),
    ] = None
    failure_action: Annotated[
        str | None,
        Field(
            description="Action to take if an update fails: 'continue', 'pause', 'rollback'."
        ),
    ] = None
    monitor: Annotated[
        str | None,
        Field(
            description="Duration to monitor each updated task for failures after it is created (e.g., '1s', '1m30s')."
        ),
    ] = None
    max_failure_ratio: Annotated[
        float | str | None,
        Field(description="Failure rate to tolerate during an update (0 to 1)."),
    ] = None
    order: Annotated[
        Literal["start-first", "stop-first"] | None,
        Field(
            description="Order of operations during updates: 'stop-first' (default) or 'start-first'."
        ),
    ] = None


class Limits(BaseModel):
    """
    Resource limits for the service containers.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    cpus: Annotated[
        float | str | None,
        Field(
            description="Limit for how much of the available CPU resources, as number of cores, a container can use."
        ),
    ] = None
    memory: Annotated[
        str | None,
        Field(
            description="Limit on the amount of memory a container can allocate (e.g., '1g', '1024m')."
        ),
    ] = None
    pids: Annotated[
        int | str | None,
        Field(description="Maximum number of PIDs available to the container."),
    ] = None


class RestartPolicy(BaseModel):
    """
    Restart policy for the service containers.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    condition: Annotated[
        str | None,
        Field(
            description="Condition for restarting the container: 'none', 'on-failure', 'any'."
        ),
    ] = None
    delay: Annotated[
        str | None,
        Field(description="Delay between restart attempts (e.g., '1s', '1m30s')."),
    ] = None
    max_attempts: Annotated[
        int | str | None,
        Field(description="Maximum number of restart attempts before giving up."),
    ] = None
    window: Annotated[
        str | None,
        Field(
            description="Time window used to evaluate the restart policy (e.g., '1s', '1m30s')."
        ),
    ] = None


class Preference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    spread: Annotated[
        str | None,
        Field(
            description="Spread tasks evenly across values of the specified node label."
        ),
    ] = None


class Placement(BaseModel):
    """
    Constraints and preferences for the platform to select a physical node to run service containers
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    constraints: Annotated[
        list[str] | None,
        Field(
            description="Placement constraints for the service (e.g., 'node.role==manager')."
        ),
    ] = None
    preferences: Annotated[
        list[Preference] | None,
        Field(description="Placement preferences for the service."),
    ] = None
    max_replicas_per_node: Annotated[
        int | str | None,
        Field(description="Maximum number of replicas of the service."),
    ] = None


class DiscreteResourceSpec(BaseModel):
    """
    Specification for discrete (countable) resources.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    kind: Annotated[
        str | None, Field(description="Type of resource (e.g., 'GPU', 'FPGA', 'SSD').")
    ] = None
    value: Annotated[
        float | str | None,
        Field(description="Number of resources of this kind to reserve."),
    ] = None


class GenericResource(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    discrete_resource_spec: Annotated[
        DiscreteResourceSpec | None,
        Field(description="Specification for discrete (countable) resources."),
    ] = None


class GenericResources(RootModel[list[GenericResource]]):
    """
    User-defined resources for services, allowing services to reserve specialized hardware resources.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        list[GenericResource],
        Field(
            description="User-defined resources for services, allowing services to reserve specialized hardware resources."
        ),
    ]


class ConfigItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    subnet: Annotated[
        str | None,
        Field(description="Subnet in CIDR format that represents a network segment."),
    ] = None
    ip_range: Annotated[
        str | None,
        Field(description="Range of IPs from which to allocate container IPs."),
    ] = None
    gateway: Annotated[
        str | None, Field(description="IPv4 or IPv6 gateway for the subnet.")
    ] = None
    aux_addresses: Annotated[
        dict[str, str] | None,
        Field(description="Auxiliary IPv4 or IPv6 addresses used by Network driver."),
    ] = None


class Ipam(BaseModel):
    """
    Custom IP Address Management configuration for this network.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    driver: Annotated[
        str | None, Field(description="Custom IPAM driver, instead of the default.")
    ] = None
    config: Annotated[
        list[ConfigItem] | None, Field(description="List of IPAM configuration blocks.")
    ] = None
    options: Annotated[
        dict[str, str] | None,
        Field(description="Driver-specific options for the IPAM driver."),
    ] = None


class External(BaseModel):
    """
    Specifies that this network already exists and was created outside of Compose.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: Annotated[
        str | None,
        Field(
            description="Specifies the name of the external network. Deprecated: use the 'name' property instead."
        ),
    ] = None


class External1(BaseModel):
    """
    Specifies that this volume already exists and was created outside of Compose.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: Annotated[
        str | None,
        Field(
            description="Specifies the name of the external volume. Deprecated: use the 'name' property instead."
        ),
    ] = None


class External2(BaseModel):
    """
    Specifies that this secret already exists and was created outside of Compose.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: Annotated[
        str | None, Field(description="Specifies the name of the external secret.")
    ] = None


class External3(BaseModel):
    """
    Specifies that this config already exists and was created outside of Compose.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: Annotated[
        str | None,
        Field(
            description="Specifies the name of the external config. Deprecated: use the 'name' property instead."
        ),
    ] = None


class Model(BaseModel):
    """
    Language Model for the Compose application.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: Annotated[str | None, Field(description="Custom name for this model.")] = None
    model: Annotated[str, Field(description="Language Model to run.")]
    context_size: int | None = None
    runtime_flags: Annotated[
        list[str] | None,
        Field(description="Raw runtime flags to pass to the inference engine."),
    ] = None


class Command(RootModel[str | list[str] | None]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        str | list[str] | None,
        Field(
            description="Command to run in the container, which can be specified as a string (shell form) or array (exec form)."
        ),
    ]


class EnvFile1(BaseModel):
    """
    Detailed configuration for an environment file.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    path: Annotated[str, Field(description="Path to the environment file.")]
    format: Annotated[
        str | None,
        Field(
            description="Format attribute lets you to use an alternative file formats for env_file. When not set, env_file is parsed according to Compose rules."
        ),
    ] = None
    required: Annotated[
        bool | str | None,
        Field(
            description="Whether the file is required. If true and the file doesn't exist, an error will be raised."
        ),
    ] = True


class EnvFile(RootModel[str | list[str | EnvFile1]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: str | list[str | EnvFile1]


class LabelFile(RootModel[str | list[str]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: str | list[str]


class ListOfStrings(RootModel[list[str]]):
    """
    A list of unique string values.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[list[str], Field(description="A list of unique string values.")]


class ListOrDict1(RootModel[list[str]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[list[str], Field(description="A list of unique string values.")]


class ListOrDict(RootModel[dict[str, str | float | bool | None] | ListOrDict1]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        dict[str, str | float | bool | None] | ListOrDict1,
        Field(
            description="Either a dictionary mapping keys to values, or a list of strings."
        ),
    ]


class ExtraHosts1(RootModel[list[str]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        list[str], Field(description="List of IP addresses for the hostname.")
    ]


class ExtraHosts2(RootModel[list[str]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        list[str],
        Field(description="List of host:IP mappings in the format 'hostname:IP'."),
    ]


class ExtraHosts(RootModel[dict[str, str | ExtraHosts1] | ExtraHosts2]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        dict[str, str | ExtraHosts1] | ExtraHosts2,
        Field(
            description="Additional hostnames to be defined in the container's /etc/hosts file."
        ),
    ]


class BlkioLimit(BaseModel):
    """
    Block IO limit for a specific device.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    path: Annotated[
        str | None, Field(description="Path to the device (e.g., '/dev/sda').")
    ] = None
    rate: Annotated[
        int | str | None,
        Field(
            description="Rate limit in bytes per second or IO operations per second."
        ),
    ] = None


class BlkioWeight(BaseModel):
    """
    Block IO weight for a specific device.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    path: Annotated[
        str | None, Field(description="Path to the device (e.g., '/dev/sda').")
    ] = None
    weight: Annotated[
        int | str | None,
        Field(description="Relative weight for the device, between 10 and 1000."),
    ] = None


class ServiceConfigOrSecret1(BaseModel):
    """
    Detailed configuration for a config or secret.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    source: Annotated[
        str | None,
        Field(
            description="Name of the config or secret as defined in the top-level configs or secrets section."
        ),
    ] = None
    target: Annotated[
        str | None,
        Field(
            description="Path in the container where the config or secret will be mounted. Defaults to /<source> for configs and /run/secrets/<source> for secrets."
        ),
    ] = None
    uid: Annotated[
        str | None,
        Field(description="UID of the file in the container. Default is 0 (root)."),
    ] = None
    gid: Annotated[
        str | None,
        Field(description="GID of the file in the container. Default is 0 (root)."),
    ] = None
    mode: Annotated[
        float | str | None,
        Field(
            description="File permission mode inside the container, in octal. Default is 0444 for configs and 0400 for secrets."
        ),
    ] = None


class ServiceConfigOrSecret(RootModel[list[str | ServiceConfigOrSecret1]]):
    """
    Configuration for service configs or secrets, defining how they are mounted in the container.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        list[str | ServiceConfigOrSecret1],
        Field(
            description="Configuration for service configs or secrets, defining how they are mounted in the container."
        ),
    ]


class Ulimits1(BaseModel):
    """
    Separate soft and hard limits.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    hard: Annotated[
        int | str,
        Field(
            description="Hard limit for the ulimit type. This is the maximum allowed value."
        ),
    ]
    soft: Annotated[
        int | str,
        Field(
            description="Soft limit for the ulimit type. This is the value that's actually enforced."
        ),
    ]


class Ulimits(RootModel[dict[str, int | str | Ulimits1]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        dict[str, int | str | Ulimits1],
        Field(
            description="Container ulimit options, controlling resource limits for processes inside the container."
        ),
    ]


class Build(BaseModel):
    """
    Configuration options for building the service's image.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    context: Annotated[
        str | None,
        Field(
            description="Path to the build context. Can be a relative path or a URL."
        ),
    ] = None
    dockerfile: Annotated[
        str | None,
        Field(description="Name of the Dockerfile to use for building the image."),
    ] = None
    dockerfile_inline: Annotated[
        str | None,
        Field(
            description="Inline Dockerfile content to use instead of a Dockerfile from the build context."
        ),
    ] = None
    entitlements: Annotated[
        list[str] | None,
        Field(
            description="List of extra privileged entitlements to grant to the build process."
        ),
    ] = None
    args: Annotated[
        ListOrDict | None,
        Field(
            description="Build-time variables, specified as a map or a list of KEY=VAL pairs."
        ),
    ] = None
    ssh: Annotated[
        ListOrDict | None,
        Field(
            description="SSH agent socket or keys to expose to the build. Format is either a string or a list of 'default|<id>[=<socket>|<key>[,<key>]]'."
        ),
    ] = None
    labels: Annotated[
        ListOrDict | None, Field(description="Labels to apply to the built image.")
    ] = None
    cache_from: Annotated[
        list[str] | None,
        Field(
            description="List of sources the image builder should use for cache resolution"
        ),
    ] = None
    cache_to: Annotated[
        list[str] | None, Field(description="Cache destinations for the build cache.")
    ] = None
    no_cache: Annotated[
        bool | str | None,
        Field(description="Do not use cache when building the image."),
    ] = None
    additional_contexts: Annotated[
        ListOrDict | None,
        Field(
            description="Additional build contexts to use, specified as a map of name to context path or URL."
        ),
    ] = None
    network: Annotated[
        str | None,
        Field(
            description="Network mode to use for the build. Options include 'default', 'none', 'host', or a network name."
        ),
    ] = None
    provenance: Annotated[
        str | bool | None, Field(description="Add a provenance attestation")
    ] = None
    sbom: Annotated[str | bool | None, Field(description="Add a SBOM attestation")] = (
        None
    )
    pull: Annotated[
        bool | str | None,
        Field(description="Always attempt to pull a newer version of the image."),
    ] = None
    target: Annotated[
        str | None,
        Field(description="Build stage to target in a multi-stage Dockerfile."),
    ] = None
    shm_size: Annotated[
        int | str | None,
        Field(
            description="Size of /dev/shm for the build container. A string value can use suffix like '2g' for 2 gigabytes."
        ),
    ] = None
    extra_hosts: Annotated[
        ExtraHosts | None,
        Field(description="Add hostname mappings for the build container."),
    ] = None
    isolation: Annotated[
        str | None,
        Field(
            description="Container isolation technology to use for the build process."
        ),
    ] = None
    privileged: Annotated[
        bool | str | None,
        Field(description="Give extended privileges to the build container."),
    ] = None
    secrets: Annotated[
        ServiceConfigOrSecret | None,
        Field(
            description="Secrets to expose to the build. These are accessible at build-time."
        ),
    ] = None
    tags: Annotated[
        list[str] | None,
        Field(description="Additional tags to apply to the built image."),
    ] = None
    ulimits: Annotated[
        Ulimits | None,
        Field(description="Override the default ulimits for the build container."),
    ] = None
    platforms: Annotated[
        list[str] | None,
        Field(
            description="Platforms to build for, e.g., 'linux/amd64', 'linux/arm64', or 'windows/amd64'."
        ),
    ] = None


class BlkioConfig(BaseModel):
    """
    Block IO configuration for the service.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    device_read_bps: Annotated[
        list[BlkioLimit] | None,
        Field(description="Limit read rate (bytes per second) from a device."),
    ] = None
    device_read_iops: Annotated[
        list[BlkioLimit] | None,
        Field(description="Limit read rate (IO per second) from a device."),
    ] = None
    device_write_bps: Annotated[
        list[BlkioLimit] | None,
        Field(description="Limit write rate (bytes per second) to a device."),
    ] = None
    device_write_iops: Annotated[
        list[BlkioLimit] | None,
        Field(description="Limit write rate (IO per second) to a device."),
    ] = None
    weight: Annotated[
        int | str | None,
        Field(
            description="Block IO weight (relative weight) for the service, between 10 and 1000."
        ),
    ] = None
    weight_device: Annotated[
        list[BlkioWeight] | None,
        Field(description="Block IO weight (relative weight) for specific devices."),
    ] = None


class Networks(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    aliases: Annotated[
        ListOfStrings | None,
        Field(description="Alternative hostnames for this service on the network."),
    ] = None
    interface_name: Annotated[
        str | None,
        Field(description="Interface network name used to connect to network"),
    ] = None
    ipv4_address: Annotated[
        str | None,
        Field(
            description="Specify a static IPv4 address for this service on this network."
        ),
    ] = None
    ipv6_address: Annotated[
        str | None,
        Field(
            description="Specify a static IPv6 address for this service on this network."
        ),
    ] = None
    link_local_ips: Annotated[
        ListOfStrings | None, Field(description="List of link-local IPs.")
    ] = None
    mac_address: Annotated[
        str | None,
        Field(description="Specify a MAC address for this service on this network."),
    ] = None
    driver_opts: Annotated[
        dict[str, str | float] | None,
        Field(description="Driver options for this network."),
    ] = None
    priority: Annotated[
        float | None,
        Field(description="Specify the priority for the network connection."),
    ] = None
    gw_priority: Annotated[
        float | None,
        Field(description="Specify the gateway priority for the network connection."),
    ] = None


class Volume1(BaseModel):
    """
    Configuration specific to volume mounts.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    labels: Annotated[
        ListOrDict | None, Field(description="Labels to apply to the volume.")
    ] = None
    nocopy: Annotated[
        bool | str | None,
        Field(
            description="Flag to disable copying of data from a container when a volume is created."
        ),
    ] = None
    subpath: Annotated[
        str | None,
        Field(
            description="Path within the volume to mount instead of the volume root."
        ),
    ] = None


class Volumes(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    type: Annotated[
        Literal["bind", "volume", "tmpfs", "cluster", "npipe", "image"],
        Field(
            description="The mount type: bind for mounting host directories, volume for named volumes, tmpfs for temporary filesystems, cluster for cluster volumes, npipe for named pipes, or image for mounting from an image."
        ),
    ]
    source: Annotated[
        str | None,
        Field(
            description="The source of the mount, a path on the host for a bind mount, a docker image reference for an image mount, or the name of a volume defined in the top-level volumes key. Not applicable for a tmpfs mount."
        ),
    ] = None
    target: Annotated[
        str | None,
        Field(description="The path in the container where the volume is mounted."),
    ] = None
    read_only: Annotated[
        bool | str | None, Field(description="Flag to set the volume as read-only.")
    ] = None
    consistency: Annotated[
        str | None,
        Field(
            description="The consistency requirements for the mount. Available values are platform specific."
        ),
    ] = None
    bind: Annotated[
        Bind | None, Field(description="Configuration specific to bind mounts.")
    ] = None
    volume: Annotated[
        Volume1 | None, Field(description="Configuration specific to volume mounts.")
    ] = None
    tmpfs: Annotated[
        Tmpfs | None, Field(description="Configuration specific to tmpfs mounts.")
    ] = None
    image: Annotated[
        Image | None, Field(description="Configuration specific to image mounts.")
    ] = None


class Device(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    capabilities: Annotated[
        ListOfStrings,
        Field(
            description="List of capabilities the device needs to have (e.g., 'gpu', 'compute', 'utility')."
        ),
    ]
    count: Annotated[
        str | int | None,
        Field(description="Number of devices of this type to reserve."),
    ] = None
    device_ids: Annotated[
        ListOfStrings | None,
        Field(description="List of specific device IDs to reserve."),
    ] = None
    driver: Annotated[
        str | None, Field(description="Device driver to use (e.g., 'nvidia').")
    ] = None
    options: Annotated[
        ListOrDict | None, Field(description="Driver-specific options for the device.")
    ] = None


class DevicesModel(RootModel[list[Device]]):
    """
    Device reservations for containers, allowing services to access specific hardware devices.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        list[Device],
        Field(
            description="Device reservations for containers, allowing services to access specific hardware devices."
        ),
    ]


class Gpu(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    capabilities: Annotated[
        ListOfStrings | None,
        Field(
            description="List of capabilities the GPU needs to have (e.g., 'compute', 'utility')."
        ),
    ] = None
    count: Annotated[str | int | None, Field(description="Number of GPUs to use.")] = (
        None
    )
    device_ids: Annotated[
        ListOfStrings | None,
        Field(description="List of specific GPU device IDs to use."),
    ] = None
    driver: Annotated[
        str | None, Field(description="GPU driver to use (e.g., 'nvidia').")
    ] = None
    options: Annotated[
        ListOrDict | None, Field(description="Driver-specific options for the GPU.")
    ] = None


class Gpus(RootModel[Literal["all"] | list[Gpu]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Literal["all"] | list[Gpu]


class Network(BaseModel):
    """
    Network configuration for the Compose application.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: Annotated[str | None, Field(description="Custom name for this network.")] = (
        None
    )
    driver: Annotated[
        str | None,
        Field(
            description="Specify which driver should be used for this network. Default is 'bridge'."
        ),
    ] = None
    driver_opts: Annotated[
        dict[str, str | float] | None,
        Field(
            description="Specify driver-specific options defined as key/value pairs."
        ),
    ] = None
    ipam: Annotated[
        Ipam | None,
        Field(
            description="Custom IP Address Management configuration for this network."
        ),
    ] = None
    external: Annotated[
        External | None,
        Field(
            description="Specifies that this network already exists and was created outside of Compose."
        ),
    ] = None
    internal: Annotated[
        bool | str | None, Field(description="Create an externally isolated network.")
    ] = None
    enable_ipv4: Annotated[
        bool | str | None, Field(description="Enable IPv4 networking.")
    ] = None
    enable_ipv6: Annotated[
        bool | str | None, Field(description="Enable IPv6 networking.")
    ] = None
    attachable: Annotated[
        bool | str | None,
        Field(description="If true, standalone containers can attach to this network."),
    ] = None
    labels: Annotated[
        ListOrDict | None,
        Field(description="Add metadata to the network using labels."),
    ] = None


class Volume(BaseModel):
    """
    Volume configuration for the Compose application.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: Annotated[str | None, Field(description="Custom name for this volume.")] = (
        None
    )
    driver: Annotated[
        str | None,
        Field(
            description="Specify which volume driver should be used for this volume."
        ),
    ] = None
    driver_opts: Annotated[
        dict[str, str | float] | None,
        Field(description="Specify driver-specific options."),
    ] = None
    external: Annotated[
        External1 | None,
        Field(
            description="Specifies that this volume already exists and was created outside of Compose."
        ),
    ] = None
    labels: Annotated[
        ListOrDict | None, Field(description="Add metadata to the volume using labels.")
    ] = None


class Secret(BaseModel):
    """
    Secret configuration for the Compose application.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: Annotated[str | None, Field(description="Custom name for this secret.")] = (
        None
    )
    environment: Annotated[
        str | None,
        Field(
            description="Name of an environment variable from which to get the secret value."
        ),
    ] = None
    file: Annotated[
        str | None, Field(description="Path to a file containing the secret value.")
    ] = None
    external: Annotated[
        External2 | None,
        Field(
            description="Specifies that this secret already exists and was created outside of Compose."
        ),
    ] = None
    labels: Annotated[
        ListOrDict | None, Field(description="Add metadata to the secret using labels.")
    ] = None
    driver: Annotated[
        str | None,
        Field(
            description="Specify which secret driver should be used for this secret."
        ),
    ] = None
    driver_opts: Annotated[
        dict[str, str | float] | None,
        Field(description="Specify driver-specific options."),
    ] = None
    template_driver: Annotated[
        str | None,
        Field(description="Driver to use for templating the secret's value."),
    ] = None


class Config(BaseModel):
    """
    Config configuration for the Compose application.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: Annotated[str | None, Field(description="Custom name for this config.")] = (
        None
    )
    content: Annotated[
        str | None, Field(description="Inline content of the config.")
    ] = None
    environment: Annotated[
        str | None,
        Field(
            description="Name of an environment variable from which to get the config value."
        ),
    ] = None
    file: Annotated[
        str | None, Field(description="Path to a file containing the config value.")
    ] = None
    external: Annotated[
        External3 | None,
        Field(
            description="Specifies that this config already exists and was created outside of Compose."
        ),
    ] = None
    labels: Annotated[
        ListOrDict | None, Field(description="Add metadata to the config using labels.")
    ] = None
    template_driver: Annotated[
        str | None,
        Field(description="Driver to use for templating the config's value."),
    ] = None


class ServiceHook(BaseModel):
    """
    Configuration for service lifecycle hooks, which are commands executed at specific points in a container's lifecycle.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    command: Annotated[
        Command, Field(description="Command to execute as part of the hook.")
    ]
    user: Annotated[str | None, Field(description="User to run the command as.")] = None
    privileged: Annotated[
        bool | str | None,
        Field(description="Whether to run the command with extended privileges."),
    ] = None
    working_dir: Annotated[
        str | None, Field(description="Working directory for the command.")
    ] = None
    environment: Annotated[
        ListOrDict | None, Field(description="Environment variables for the command.")
    ] = None


class StringOrList(RootModel[str | ListOfStrings]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        str | ListOfStrings,
        Field(description="Either a single string or a list of strings."),
    ]


class WatchItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    ignore: Annotated[
        StringOrList | None, Field(description="Patterns to exclude from watching.")
    ] = None
    include: Annotated[
        StringOrList | None, Field(description="Patterns to include in watching.")
    ] = None
    path: Annotated[str, Field(description="Path to watch for changes.")]
    action: Annotated[
        Literal["rebuild", "sync", "restart", "sync+restart", "sync+exec"],
        Field(
            description="Action to take when a change is detected: rebuild the container, sync files, restart the container, sync and restart, or sync and execute a command."
        ),
    ]
    target: Annotated[
        str | None,
        Field(description="Target path in the container for sync operations."),
    ] = None
    exec: Annotated[
        ServiceHook | None,
        Field(
            description="Command to execute when a change is detected and action is sync+exec."
        ),
    ] = None
    initial_sync: Annotated[
        bool | None,
        Field(
            description="Ensure that an initial synchronization is done before starting watch mode for sync+x triggers"
        ),
    ] = None


class Development(BaseModel):
    """
    Development configuration for the service, used for development workflows.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    watch: Annotated[
        list[WatchItem] | None,
        Field(
            description="Configure watch mode for the service, which monitors file changes and performs actions in response."
        ),
    ] = None


class Reservations(BaseModel):
    """
    Resource reservations for the service containers.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    cpus: Annotated[
        float | str | None,
        Field(
            description="Reservation for how much of the available CPU resources, as number of cores, a container can use."
        ),
    ] = None
    memory: Annotated[
        str | None,
        Field(
            description="Reservation on the amount of memory a container can allocate (e.g., '1g', '1024m')."
        ),
    ] = None
    generic_resources: Annotated[
        GenericResources | None, Field(description="User-defined resources to reserve.")
    ] = None
    devices: Annotated[
        DevicesModel | None, Field(description="Device reservations for the container.")
    ] = None


class Resources(BaseModel):
    """
    Resource constraints and reservations for the service.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    limits: Annotated[
        Limits | None, Field(description="Resource limits for the service containers.")
    ] = None
    reservations: Annotated[
        Reservations | None,
        Field(description="Resource reservations for the service containers."),
    ] = None


class Deployment(BaseModel):
    """
    Deployment configuration for the service.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    mode: Annotated[
        str | None,
        Field(
            description="Deployment mode for the service: 'replicated' (default) or 'global'."
        ),
    ] = None
    endpoint_mode: Annotated[
        str | None,
        Field(description="Endpoint mode for the service: 'vip' (default) or 'dnsrr'."),
    ] = None
    replicas: Annotated[
        int | str | None,
        Field(description="Number of replicas of the service container to run."),
    ] = None
    labels: Annotated[
        ListOrDict | None, Field(description="Labels to apply to the service.")
    ] = None
    rollback_config: Annotated[
        RollbackConfig | None,
        Field(description="Configuration for rolling back a service update."),
    ] = None
    update_config: Annotated[
        UpdateConfig | None, Field(description="Configuration for updating a service.")
    ] = None
    resources: Annotated[
        Resources | None,
        Field(description="Resource constraints and reservations for the service."),
    ] = None
    restart_policy: Annotated[
        RestartPolicy | None,
        Field(description="Restart policy for the service containers."),
    ] = None
    placement: Annotated[
        Placement | None,
        Field(
            description="Constraints and preferences for the platform to select a physical node to run service containers"
        ),
    ] = None


class Include1(BaseModel):
    """
    Compose application or sub-projects to be included.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    path: Annotated[
        StringOrList | None,
        Field(
            description="Path to the Compose application or sub-project files to include."
        ),
    ] = None
    env_file: Annotated[
        StringOrList | None,
        Field(
            description="Path to the environment files to use to define default values when interpolating variables in the Compose files being parsed."
        ),
    ] = None
    project_directory: Annotated[
        str | None,
        Field(description="Path to resolve relative paths set in the Compose file"),
    ] = None


class Include(RootModel[str | Include1]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[
        str | Include1,
        Field(description="Compose application or sub-projects to be included."),
    ]


class Service(BaseModel):
    """
    Configuration for a service.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    develop: Development | None = None
    deploy: Deployment | None = None
    annotations: ListOrDict | None = None
    attach: bool | str | None = None
    build: Annotated[
        str | Build | None,
        Field(description="Configuration options for building the service's image."),
    ] = None
    blkio_config: Annotated[
        BlkioConfig | None, Field(description="Block IO configuration for the service.")
    ] = None
    cap_add: Annotated[
        list[str] | None,
        Field(
            description="Add Linux capabilities. For example, 'CAP_SYS_ADMIN', 'SYS_ADMIN', or 'NET_ADMIN'."
        ),
    ] = None
    cap_drop: Annotated[
        list[str] | None,
        Field(
            description="Drop Linux capabilities. For example, 'CAP_SYS_ADMIN', 'SYS_ADMIN', or 'NET_ADMIN'."
        ),
    ] = None
    cgroup: Annotated[
        Literal["host", "private"] | None,
        Field(
            description="Specify the cgroup namespace to join. Use 'host' to use the host's cgroup namespace, or 'private' to use a private cgroup namespace."
        ),
    ] = None
    cgroup_parent: Annotated[
        str | None,
        Field(description="Specify an optional parent cgroup for the container."),
    ] = None
    command: Annotated[
        Command | None,
        Field(
            description="Override the default command declared by the container image, for example 'CMD' in Dockerfile."
        ),
    ] = None
    configs: Annotated[
        ServiceConfigOrSecret | None,
        Field(description="Grant access to Configs on a per-service basis."),
    ] = None
    container_name: Annotated[
        str | None,
        Field(
            description="Specify a custom container name, rather than a generated default name.",
            pattern="[a-zA-Z0-9][a-zA-Z0-9_.-]+",
        ),
    ] = None
    cpu_count: Annotated[
        str | CpuCount | None, Field(description="Number of usable CPUs.")
    ] = None
    cpu_percent: Annotated[
        str | CpuPercent | None,
        Field(description="Percentage of CPU resources to use."),
    ] = None
    cpu_shares: Annotated[
        float | str | None,
        Field(description="CPU shares (relative weight) for the container."),
    ] = None
    cpu_quota: Annotated[
        float | str | None,
        Field(description="Limit the CPU CFS (Completely Fair Scheduler) quota."),
    ] = None
    cpu_period: Annotated[
        float | str | None,
        Field(description="Limit the CPU CFS (Completely Fair Scheduler) period."),
    ] = None
    cpu_rt_period: Annotated[
        float | str | None,
        Field(
            description="Limit the CPU real-time period in microseconds or a duration."
        ),
    ] = None
    cpu_rt_runtime: Annotated[
        float | str | None,
        Field(
            description="Limit the CPU real-time runtime in microseconds or a duration."
        ),
    ] = None
    cpus: Annotated[
        float | str | None,
        Field(
            description="Number of CPUs to use. A floating-point value is supported to request partial CPUs."
        ),
    ] = None
    cpuset: Annotated[
        str | None, Field(description="CPUs in which to allow execution (0-3, 0,1).")
    ] = None
    credential_spec: Annotated[
        CredentialSpec | None,
        Field(description="Configure the credential spec for managed service account."),
    ] = None
    depends_on: Annotated[
        ListOfStrings | dict[str, DependsOn] | None,
        Field(
            description="Express dependency between services. Service dependencies cause services to be started in dependency order. The dependent service will wait for the dependency to be ready before starting."
        ),
    ] = None
    device_cgroup_rules: Annotated[
        ListOfStrings | None,
        Field(description="Add rules to the cgroup allowed devices list."),
    ] = None
    devices: Annotated[
        list[str | Devices] | None,
        Field(description="List of device mappings for the container."),
    ] = None
    dns: Annotated[
        StringOrList | None,
        Field(description="Custom DNS servers to set for the service container."),
    ] = None
    dns_opt: Annotated[
        list[str] | None,
        Field(
            description="Custom DNS options to be passed to the container's DNS resolver."
        ),
    ] = None
    dns_search: Annotated[
        StringOrList | None,
        Field(description="Custom DNS search domains to set on the service container."),
    ] = None
    domainname: Annotated[
        str | None,
        Field(description="Custom domain name to use for the service container."),
    ] = None
    entrypoint: Annotated[
        Command | None,
        Field(
            description="Override the default entrypoint declared by the container image, for example 'ENTRYPOINT' in Dockerfile."
        ),
    ] = None
    env_file: Annotated[
        EnvFile | None,
        Field(
            description="Add environment variables from a file or multiple files. Can be a single file path or a list of file paths."
        ),
    ] = None
    label_file: Annotated[
        LabelFile | None,
        Field(
            description="Add metadata to containers using files containing Docker labels."
        ),
    ] = None
    environment: Annotated[
        ListOrDict | None,
        Field(
            description="Add environment variables. You can use either an array or a list of KEY=VAL pairs."
        ),
    ] = None
    expose: Annotated[
        list[str | float] | None,
        Field(
            description="Expose ports without publishing them to the host machine - they'll only be accessible to linked services."
        ),
    ] = None
    extends: Annotated[
        str | Extends | None,
        Field(
            description="Extend another service, in the current file or another file."
        ),
    ] = None
    provider: Annotated[
        Provider | None,
        Field(
            description="Specify a service which will not be manage by Compose directly, and delegate its management to an external provider."
        ),
    ] = None
    external_links: Annotated[
        list[str] | None,
        Field(
            description="Link to services started outside this Compose application. Specify services as <service_name>:<alias>."
        ),
    ] = None
    extra_hosts: Annotated[
        ExtraHosts | None,
        Field(
            description="Add hostname mappings to the container network interface configuration."
        ),
    ] = None
    gpus: Annotated[
        Gpus | None,
        Field(
            description="Define GPU devices to use. Can be set to 'all' to use all GPUs, or a list of specific GPU devices."
        ),
    ] = None
    group_add: Annotated[
        list[str | float] | None,
        Field(
            description="Add additional groups which user inside the container should be member of."
        ),
    ] = None
    healthcheck: Annotated[
        Healthcheck | None,
        Field(
            description="Configure a health check for the container to monitor its health status."
        ),
    ] = None
    hostname: Annotated[
        str | None,
        Field(description="Define a custom hostname for the service container."),
    ] = None
    image: Annotated[
        str | None,
        Field(
            description="Specify the image to start the container from. Can be a repository/tag, a digest, or a local image ID."
        ),
    ] = None
    init: Annotated[
        bool | str | None,
        Field(
            description="Run as an init process inside the container that forwards signals and reaps processes."
        ),
    ] = None
    ipc: Annotated[
        str | None,
        Field(
            description="IPC sharing mode for the service container. Use 'host' to share the host's IPC namespace, 'service:[service_name]' to share with another service, or 'shareable' to allow other services to share this service's IPC namespace."
        ),
    ] = None
    isolation: Annotated[
        str | None,
        Field(
            description="Container isolation technology to use. Supported values are platform-specific."
        ),
    ] = None
    labels: Annotated[
        ListOrDict | None,
        Field(
            description="Add metadata to containers using Docker labels. You can use either an array or a list."
        ),
    ] = None
    links: Annotated[
        list[str] | None,
        Field(
            description="Link to containers in another service. Either specify both the service name and a link alias (SERVICE:ALIAS), or just the service name."
        ),
    ] = None
    logging: Annotated[
        Logging | None, Field(description="Logging configuration for the service.")
    ] = None
    mac_address: Annotated[
        str | None, Field(description="Container MAC address to set.")
    ] = None
    mem_limit: Annotated[
        float | str | None,
        Field(
            description="Memory limit for the container. A string value can use suffix like '2g' for 2 gigabytes."
        ),
    ] = None
    mem_reservation: Annotated[
        str | int | None, Field(description="Memory reservation for the container.")
    ] = None
    mem_swappiness: Annotated[
        int | str | None,
        Field(description="Container memory swappiness as percentage (0 to 100)."),
    ] = None
    memswap_limit: Annotated[
        float | str | None,
        Field(
            description="Amount of memory the container is allowed to swap to disk. Set to -1 to enable unlimited swap."
        ),
    ] = None
    network_mode: Annotated[
        str | None,
        Field(
            description="Network mode. Values can be 'bridge', 'host', 'none', 'service:[service name]', or 'container:[container name]'."
        ),
    ] = None
    models: Annotated[
        ListOfStrings | dict[str, Models] | None,
        Field(
            description="AI Models to use, referencing entries under the top-level models key."
        ),
    ] = None
    networks: Annotated[
        ListOfStrings | dict[str, Networks | None] | None,
        Field(
            description="Networks to join, referencing entries under the top-level networks key. Can be a list of network names or a mapping of network name to network configuration."
        ),
    ] = None
    oom_kill_disable: Annotated[
        bool | str | None, Field(description="Disable OOM Killer for the container.")
    ] = None
    oom_score_adj: Annotated[
        str | OomScoreAdj | None,
        Field(
            description="Tune host's OOM preferences for the container (accepts -1000 to 1000)."
        ),
    ] = None
    pid: Annotated[str | None, Field(description="PID mode for container.")] = None
    pids_limit: Annotated[
        float | str | None,
        Field(
            description="Tune a container's PIDs limit. Set to -1 for unlimited PIDs."
        ),
    ] = None
    platform: Annotated[
        str | None,
        Field(
            description="Target platform to run on, e.g., 'linux/amd64', 'linux/arm64', or 'windows/amd64'."
        ),
    ] = None
    ports: Annotated[
        list[float | str | Ports] | None,
        Field(
            description="Expose container ports. Short format ([HOST:]CONTAINER[/PROTOCOL])."
        ),
    ] = None
    post_start: Annotated[
        list[ServiceHook] | None,
        Field(
            description="Commands to run after the container starts. If any command fails, the container stops."
        ),
    ] = None
    pre_stop: Annotated[
        list[ServiceHook] | None,
        Field(
            description="Commands to run before the container stops. If any command fails, the container stop is aborted."
        ),
    ] = None
    privileged: Annotated[
        bool | str | None,
        Field(description="Give extended privileges to the service container."),
    ] = None
    profiles: Annotated[
        ListOfStrings | None,
        Field(
            description="List of profiles for this service. When profiles are specified, services are only started when the profile is activated."
        ),
    ] = None
    pull_policy: Annotated[
        str | None,
        Field(
            description="Policy for pulling images. Options include: 'always', 'never', 'if_not_present', 'missing', 'build', or time-based refresh policies.",
            pattern="always|never|build|if_not_present|missing|refresh|daily|weekly|every_([0-9]+[wdhms])+",
        ),
    ] = None
    pull_refresh_after: Annotated[
        str | None,
        Field(
            description="Time after which to refresh the image. Used with pull_policy=refresh."
        ),
    ] = None
    read_only: Annotated[
        bool | str | None,
        Field(description="Mount the container's filesystem as read only."),
    ] = None
    restart: Annotated[
        str | None,
        Field(
            description="Restart policy for the service container. Options include: 'no', 'always', 'on-failure', and 'unless-stopped'."
        ),
    ] = None
    runtime: Annotated[
        str | None,
        Field(description="Runtime to use for this container, e.g., 'runc'."),
    ] = None
    scale: Annotated[
        int | str | None,
        Field(description="Number of containers to deploy for this service."),
    ] = None
    security_opt: Annotated[
        list[str] | None,
        Field(description="Override the default labeling scheme for each container."),
    ] = None
    shm_size: Annotated[
        float | str | None,
        Field(
            description="Size of /dev/shm. A string value can use suffix like '2g' for 2 gigabytes."
        ),
    ] = None
    secrets: Annotated[
        ServiceConfigOrSecret | None,
        Field(description="Grant access to Secrets on a per-service basis."),
    ] = None
    sysctls: Annotated[
        ListOrDict | None,
        Field(
            description="Kernel parameters to set in the container. You can use either an array or a list."
        ),
    ] = None
    stdin_open: Annotated[
        bool | str | None, Field(description="Keep STDIN open even if not attached.")
    ] = None
    stop_grace_period: Annotated[
        str | None,
        Field(
            description="Time to wait for the container to stop gracefully before sending SIGKILL (e.g., '1s', '1m30s')."
        ),
    ] = None
    stop_signal: Annotated[
        str | None,
        Field(description="Signal to stop the container (e.g., 'SIGTERM', 'SIGINT')."),
    ] = None
    storage_opt: Annotated[
        dict[str, Any] | None,
        Field(description="Storage driver options for the container."),
    ] = None
    tmpfs: Annotated[
        StringOrList | None,
        Field(
            description="Mount a temporary filesystem (tmpfs) into the container. Can be a single value or a list."
        ),
    ] = None
    tty: Annotated[
        bool | str | None,
        Field(description="Allocate a pseudo-TTY to service container."),
    ] = None
    ulimits: Annotated[
        Ulimits | None,
        Field(description="Override the default ulimits for a container."),
    ] = None
    use_api_socket: Annotated[
        bool | None,
        Field(description="Bind mount Docker API socket and required auth."),
    ] = None
    user: Annotated[
        str | None,
        Field(description="Username or UID to run the container process as."),
    ] = None
    uts: Annotated[
        str | None,
        Field(
            description="UTS namespace to use. 'host' shares the host's UTS namespace."
        ),
    ] = None
    userns_mode: Annotated[
        str | None,
        Field(
            description="User namespace to use. 'host' shares the host's user namespace."
        ),
    ] = None
    volumes: Annotated[
        list[str | Volumes] | None,
        Field(
            description="Mount host paths or named volumes accessible to the container. Short syntax (VOLUME:CONTAINER_PATH[:MODE])"
        ),
    ] = None
    volumes_from: Annotated[
        list[str] | None,
        Field(
            description="Mount volumes from another service or container. Optionally specify read-only access (ro) or read-write (rw)."
        ),
    ] = None
    working_dir: Annotated[
        str | None,
        Field(
            description="The working directory in which the entrypoint or command will be run"
        ),
    ] = None


class ComposeSpecification(BaseModel):
    """
    The Compose file is a YAML file defining a multi-containers based application.
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    version: Annotated[
        str | None,
        Field(
            description="declared for backward compatibility, ignored. Please remove it."
        ),
    ] = None
    name: Annotated[
        str | None,
        Field(
            description="define the Compose project name, until user defines one explicitly."
        ),
    ] = None
    include: Annotated[
        list[Include] | None, Field(description="compose sub-projects to be included.")
    ] = None
    services: Annotated[
        dict[str, Service] | None,
        Field(description="The services that will be used by your application."),
    ] = None
    models: Annotated[
        dict[str, Model] | None,
        Field(description="Language models that will be used by your application."),
    ] = None
    networks: Annotated[
        dict[str, Network | None] | None,
        Field(description="Networks that are shared among multiple services."),
    ] = None
    volumes: Annotated[
        dict[str, Volume | None] | None,
        Field(description="Named volumes that are shared among multiple services."),
    ] = None
    secrets: Annotated[
        dict[str, Secret] | None,
        Field(description="Secrets that are shared among multiple services."),
    ] = None
    configs: Annotated[
        dict[str, Config] | None,
        Field(description="Configurations that are shared among multiple services."),
    ] = None
